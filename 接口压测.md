# Spring Boot API 压测增强版提示词（修正优化版）
name: "spring-boot-api-pressure-test-enhanced"
description: "Spring Boot API全流程压测：先命令校验JMeter/Arthas环境，自动分析接口数据依赖、多方式生成可用测试数据，基于机器性能预测QPS并定制压测计划，生成可执行JMeter脚本，结合Arthas全指标监控分析瓶颈，最终输出标准化HTML压测报告并提供完整HTML模板。"

## 核心定位&适用场景
**适配环境**：
- Java Spring Boot项目（支持Spring生态@Lazy懒加载启动，降低压测指标失真）
- 需瓶颈定位的RESTful API接口（秒杀/库存/高并发查询/数据创建类接口为主）
- 单机/集群压测环境均支持

**解决核心问题**：
- 压测前无工具环境校验，手动下载配置效率低、易出问题
- 测试数据无来源/不可用，接口无法正常执行压测
- 仅按主观预期设计QPS，未结合机器性能做科学预测，压测计划不合理
- 压测仅关注表面指标，无底层JVM/线程/SQL级别的瓶颈分析
- 压测结果无标准化HTML报告，指标展示不直观、优化建议无依据

**技能目标**：
从**工具环境校验→数据依赖分析→测试数据生成→QPS预测→压测计划定制→脚本生成→压测执行+全指标监控→瓶颈分析→HTML报告输出**形成全闭环，输出的所有脚本/命令/模板均可直接使用，无需手动二次调整。

## 核心能力1：JMeter/Arthas工具环境命令式校验+一键配置（压测前置必做）
### 校验规则
压测前**必须通过终端命令依次校验Arthas、JMeter是否已安装并配置环境变量**，仅当命令校验通过（可正常输出版本/启动），才进入后续步骤；未安装则输出**分系统（Linux/Windows/Mac）的一键下载、安装、环境变量配置步骤**，确保用户可快速完成可命令行调用的工具环境搭建。

### 一、Arthas命令校验+环境配置
#### 1. 命令校验（核心：可任意目录执行）
```bash
# 校验是否可全局调用，输出版本则环境配置成功
java -jar arthas-boot.jar -v
# 备用校验：检查是否存在核心包
ls /usr/local/arthas/arthas-boot.jar # Linux/Mac
dir C:\arthas\arthas-boot.jar        # Windows
```
#### 2. 未安装则输出分系统配置步骤（一键可用）
##### Linux/Mac（一键下载+全局可调用配置）
```bash
# 1. 下载核心包到全局目录
curl -O https://arthas.aliyun.com/arthas-boot.jar && mv arthas-boot.jar /usr/local/arthas/
# 2. 配置环境变量（永久生效）
echo 'alias arthas="java -jar /usr/local/arthas/arthas-boot.jar"' >> ~/.bashrc # bash
echo 'alias arthas="java -jar /usr/local/arthas/arthas-boot.jar"' >> ~/.zshrc # zsh
source ~/.bashrc || source ~/.zshrc
# 3. 校验：任意目录执行arthas，可列出Java进程即成功
arthas
```
##### Windows（下载+环境变量配置）
1. 直接下载：https://arthas.aliyun.com/arthas-boot.jar，保存到`C:\arthas\`
2. 配置系统环境变量：新增系统变量`ARTHAS_HOME=C:\arthas`，Path中添加`%ARTHAS_HOME%`
3. 新增批处理文件`arthas.bat`到`C:\arthas\`，内容为：`@java -jar C:\arthas\arthas-boot.jar %*`
4. 校验：CMD任意目录执行`arthas`，可列出Java进程即成功

### 二、JMeter命令校验+环境配置（关键：JMeter支持命令行全局调用）
#### 1. 命令校验（核心：可任意目录执行，直接输出版本）
```bash
# 核心校验命令，输出版本号则环境配置成功（支持全局调用）
jmeter -v
```
**说明**：JMeter本身支持命令行全局调用，只要配置好环境变量，即可通过`jmeter -v`直接校验，无需额外依赖，这是JMeter的原生特性。

#### 2. 未安装则输出分系统配置步骤（一键可用，含JDK前置校验）
##### 前置条件
JDK 8/11/17已安装，执行`java -version`可正常输出版本（推荐JDK8，兼容性最佳）。

##### Linux/Mac（下载+环境变量配置+全局调用）
```bash
# 1. 下载JMeter5.6.3（稳定版）到/opt目录
wget https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-5.6.3.zip -P /opt
# 2. 解压
unzip /opt/apache-jmeter-5.6.3.zip -d /opt
# 3. 配置环境变量（永久生效）
echo 'export JMETER_HOME=/opt/apache-jmeter-5.6.3' >> /etc/profile
echo 'export PATH=$PATH:$JMETER_HOME/bin' >> /etc/profile
# 4. 生效配置
source /etc/profile
# 5. 校验：任意目录执行jmeter -v，输出版本即成功
jmeter -v
```
##### Windows（下载+环境变量配置+全局调用）
1. 下载稳定版：https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-5.6.3.zip
2. 解压到固定目录（如`D:\apache-jmeter-5.6.3`，路径无空格/中文）
3. 配置系统环境变量：新增`JMETER_HOME=D:\apache-jmeter-5.6.3`，Path中添加`%JMETER_HOME%\bin`
4. 校验：CMD任意目录执行`jmeter -v`，输出版本号即配置成功。

#### 3. JMeter核心命令说明（压测专用，无GUI模式）
```bash
# 执行压测脚本+生成原始结果文件
jmeter -n -t 压测脚本.jmx -l 测试结果.jtl
# 执行压测+直接生成HTML报告（推荐，一步到位）
jmeter -n -t 压测脚本.jmx -l 测试结果.jtl -e -o html-report/
```

## 核心能力2：接口全链路数据依赖分析（从接口向下穿透，无遗漏）
### 分析规则
用户提供目标压测接口信息（地址/请求方式/入参示例/业务逻辑）后，**从接口层向下逐层分析所有数据依赖**，形成结构化的依赖清单，确保后续测试数据覆盖所有必要维度，接口可正常执行。
### 分析维度（逐层穿透，必含以下内容）
1. **接口层**：必传/可选入参、参数类型/取值范围、请求方式（GET/POST/PUT/DELETE）、请求头要求（Token/Content-Type等）；
2. **业务服务层**：接口依赖的业务方法、方法所需的业务数据（如用户ID/商品ID/库存数）、数据关联关系（如用户ID需存在、商品ID需与库存关联）；
3. **数据持久层**：依赖的数据库表/缓存Key（Redis/Memcached）、表字段约束（非空/唯一/取值范围）、缓存与数据库的一致性要求；
4. **外部依赖层**：是否依赖第三方接口（如支付/短信）、MQ队列、分布式锁等，及对应依赖的入参/数据要求。
### 输出格式（结构化清单，直观易读）
```markdown
# 【接口XXX】数据依赖分析清单
## 1. 接口层依赖
- 请求地址：/api/v1/seckill
- 请求方式：POST
- 必传入参：userId（Long，1000-9999）、productId（Long，5000-5999）、num（Int，仅能为1）
- 请求头：Content-Type=application/json、Token（有效用户令牌）

## 2. 业务服务层依赖
- 依赖方法：SeckillService.doSeckill(userId, productId, num)
- 业务数据要求：userId为已注册用户、productId为上架商品、商品库存≥num

## 3. 数据持久层依赖
### 数据库表
- user（用户表）：userId（主键）、userName、token（有效）
- product（商品表）：productId（主键）、productName、status（1=上架）
- stock（库存表）：productId（外键）、stockNum（≥1）
### 缓存（Redis）
- 缓存Key：seckill:stock:{productId}（值为库存数，需与数据库一致）
- 分布式锁Key：seckill:lock:{productId}（无特殊数据要求）

## 4. 外部依赖层
- 无第三方接口/MQ依赖，仅依赖Redis分布式锁
```

## 核心能力3：测试数据生成（优先获取+自动生成，确保接口可跑通）
### 生成规则
基于上述数据依赖清单，**优先从测试环境获取真实数据，真实数据不足/无测试环境时，自动生成符合所有约束的模拟数据**，最终输出**JMeter可直接调用的CSV格式数据文件**（压测脚本专用），确保压测时接口无「数据不存在/参数不合法」等错误。
### 步骤1：测试环境真实数据获取（推荐，无侵入）
提供**可直接执行的请求命令/查询语句**，从项目原生接口/数据库获取数据，**禁止手动连接数据库直接修改**，仅做查询。
#### 示例（秒杀接口数据获取）
```bash
# 1. 从项目查询接口获取有效用户ID（输出JSON）
curl -X GET "http://测试环境IP:8080/api/v1/user/valid" -H "Token: 测试环境有效令牌" > user.json
# 2. 从项目查询接口获取有效商品ID+库存
curl -X GET "http://测试环境IP:8080/api/v1/product/onSale" -H "Token: 测试环境有效令牌" > product.json
# 3. 数据库查询（仅读，获取库存≥1的商品）
mysql -h 测试环境DBIP -u 用户名 -p 密码 -e "SELECT productId, stockNum FROM seckill.stock WHERE stockNum >=1;" > stock.sql
```
同时提供**数据提取命令**，将上述JSON/SQL结果提取为纯数据，方便转换为CSV：
```bash
# 提取user.json中的userId，去重后输出
cat user.json | jq '.data[] | .userId' | tr -d '"' | uniq > userId.txt
# 提取product.json中的productId（上架状态）
cat product.json | jq '.data[] | select(.status==1) | .productId' | tr -d '"' > productId.txt
```

### 步骤2：模拟数据自动生成（真实数据不足时）
根据数据依赖的**参数约束/取值范围/关联关系**，提供**Python/Shell可执行脚本**，自动生成符合所有要求的模拟数据，最终输出CSV文件。
#### 示例（秒杀接口模拟数据生成脚本，Python）
```python
import csv
import random

# 符合数据依赖约束：userId(1000-9999)、productId(5000-5999)、num=1、token有效格式
def generate_test_data(row_num=1000):
    # 生成有效Token（模拟格式）
    def gen_token():
        return f"token_{random.randint(100000, 999999)}"
    # 生成数据
    data = []
    for _ in range(row_num):
        userId = random.randint(1000, 9999)
        productId = random.randint(5000, 5999)
        num = 1
        token = gen_token()
        data.append([userId, productId, num, token])
    # 写入CSV（JMeter专用，首行为变量名）
    with open("test_data.csv", "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["userId", "productId", "num", "token"])
        writer.writerows(data)

if __name__ == "__main__":
    generate_test_data(2000) # 生成2000条测试数据
```
### 最终输出
- 符合JMeter参数化要求的`test_data.csv`文件（首行为变量名，与接口入参一一对应）；
- 数据使用说明（告知JMeter如何配置CSV数据读取）。

## 核心能力4：基于机器性能的QPS科学预测+定制化压测计划
### 步骤1：获取压测执行机硬件参数
用户提供**压测机硬件性能（CPU核心数/内存大小/操作系统，例：8核16GB Ubuntu22.04）**，无提供时默认按「4核8GB CentOS7」处理。
### 步骤2：QPS科学预测
基于压测机CPU核心数做**基础QPS预测**，结合接口类型（查询类/写操作类）做系数调整，最终输出**合理的基准QPS**，避免主观臆断。
#### 预测公式（实战落地版，适合Spring Boot接口）
```
# 基础QPS = CPU核心数 × 系数（根据接口类型调整）
- 纯查询类接口（仅查缓存/无DB操作）：系数=100 → 8核=800 QPS
- 简单写操作类（缓存+轻量DB操作）：系数=50 → 8核=400 QPS
- 复杂业务类（秒杀/库存扣减，含分布式锁/多表操作）：系数=20 → 8核=160 QPS
```
#### 预测结果输出
明确给出**基准QPS**+**压力上限QPS**（基准QPS×1.2），作为压测梯度设计的核心依据。

### 步骤3：定制标准化压测计划（结合预测QPS，可直接执行）
#### 计划核心规则
- 每个梯度包含「1分钟预热（避免JVM冷启动影响）+5分钟正式压测+1分钟冷却（让JVM恢复基线）」，单梯度总时长7分钟；
- 梯度设计分3档：基准QPS×0.5（基础验证）、基准QPS（目标验证）、基准QPS×1.2（极限压力验证）；
- 设定强制停止条件：接口成功率＜95%/出现OOM/数据库连接池耗尽，立即终止压测。
#### 计划输出格式（结构化，含所有执行细节）
```markdown
# 压测计划 - 目标接口：/api/v1/seckill
## 基础信息
- 压测机性能：8核16GB Ubuntu22.04
- 接口类型：复杂业务类（秒杀）
- 预测基准QPS：160 | 压力上限QPS：192
- 核心监控指标：QPS/平均RT/P99/P95/成功率/失败率/CPU使用率/GC频率/慢SQL

## 压测梯度设计（3档）
| 梯度编号 | 并发数 | 总时长 | 核心测试点 | 预期QPS | 停止条件 |
|----------|--------|--------|------------|---------|----------|
| 1        | 80     | 7分钟  | 基础性能验证，确认接口无基础问题 | 80      | 成功率＜99%则停止 |
| 2        | 160    | 7分钟  | 基准QPS达标验证，核心指标监控 | 160     | 成功率＜97%则停止 |
| 3        | 192    | 7分钟  | 极限压力验证，定位性能瓶颈 | 192     | 成功率＜95%则停止 |

## 配套执行命令
### JMeter压测命令（无GUI，直接生成HTML报告）
jmeter -n -t seckill_test.jmx -l seckill_result.jtl -e -o seckill_html_report/
### Arthas监控命令（与压测同时启动，保存监控日志）
arthas dashboard -n 1000 > dashboard.log && thread -n 10 -i 2000 > thread.log && trace com.seckill.service.SeckillService doSeckill -j > trace.log
```

## 核心能力5：可直接执行的JMeter压测脚本生成（集成参数化+断言）
### 脚本核心要求
- 集成CSV参数化配置，直接读取上述`test_data.csv`文件，自动循环取数；
- 添加**响应断言**（校验接口返回码/核心字段，例：返回码200、success=true）；
- 配置**线程组**（与压测计划梯度的并发数/时长一一对应）；
- 启用**全指标收集**（QPS/RT/P99/失败率等，为后续报告提供数据）；
- 输出**JMX格式脚本**+**脚本使用说明**（如何修改并发数/数据文件路径）。

### 脚本示例（核心片段，完整可运行）
```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="秒杀接口压测计划" enabled="true">
    <stringProp name="TestPlan.comments">Spring Boot秒杀接口压测，集成CSV参数化/响应断言</stringProp>
    <boolProp name="TestPlan.functional_mode">false</boolProp>
    <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
    <elementProp name="TestPlan.arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="用户定义的变量" enabled="true"/>
    <stringProp name="TestPlan.user_define_classpath"></stringProp>
  </TestPlan>
  <!-- 线程组：对应压测计划梯度，修改num_threads/ RampUp/loop_count即可适配不同梯度 -->
  <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="秒杀接口线程组" enabled="true">
    <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
    <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="循环控制器" enabled="true">
      <boolProp name="LoopController.continue_forever">false</boolProp>
      <stringProp name="LoopController.loops">-1</stringProp> <!-- 无限循环，由压测时长控制 -->
    </elementProp>
    <stringProp name="ThreadGroup.num_threads">160</stringProp> <!-- 并发数，对应压测梯度 -->
    <stringProp name="ThreadGroup.ramp_time">60</stringProp> <!-- 预热时间，60秒 -->
    <boolProp name="ThreadGroup.scheduler">true</boolProp> <!-- 启用时长调度 -->
    <stringProp name="ThreadGroup.duration">420</stringProp> <!-- 单梯度总时长，7分钟=420秒 -->
    <stringProp name="ThreadGroup.delay">0</stringProp>
    <boolProp name="ThreadGroup.same_user_on_next_iteration">true</boolProp>
  </ThreadGroup>
  <!-- CSV数据配置：读取test_data.csv，参数化入参 -->
  <CSVDataSet guiclass="CSVDataSetGui" testclass="CSVDataSet" testname="CSV数据配置" enabled="true">
    <stringProp name="delimiter">,</stringProp>
    <stringProp name="fileEncoding">UTF-8</stringProp>
    <stringProp name="filename">test_data.csv</stringProp> <!-- 数据文件路径，与脚本同目录即可 -->
    <boolProp name="ignoreFirstLine">true</boolProp> <!-- 忽略首行（变量名） -->
    <boolProp name="quotedData">false</boolProp>
    <boolProp name="recycle">true</boolProp> <!-- 循环取数 -->
    <stringProp name="variableNames">userId,productId,num,token</stringProp> <!-- 与CSV首行一致 -->
    <boolProp name="stopThread">false</boolProp>
  </CSVDataSet>
  <!-- HTTP请求：目标压测接口 -->
  <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="秒杀接口POST请求" enabled="true">
    <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="请求参数" enabled="true">
      <collectionProp name="Arguments.arguments">
        <elementProp name="userId" elementType="HTTPArgument" guiclass="HTTPArgumentGui" testclass="HTTPArgument" testname="userId" enabled="true">
          <stringProp name="Argument.value">${userId}</stringProp> <!-- 引用CSV变量 -->
          <stringProp name="Argument.metadata">=</stringProp>
          <boolProp name="HTTPArgument.always_encode">false</boolProp>
        </elementProp>
        <elementProp name="productId" elementType="HTTPArgument" guiclass="HTTPArgumentGui" testclass="HTTPArgument" testname="productId" enabled="true">
          <stringProp name="Argument.value">${productId}</stringProp>
          <stringProp name="Argument.metadata">=</stringProp>
          <boolProp name="HTTPArgument.always_encode">false</boolProp>
        </elementProp>
        <elementProp name="num" elementType="HTTPArgument" guiclass="HTTPArgumentGui" testclass="HTTPArgument" testname="num" enabled="true">
          <stringProp name="Argument.value">${num}</stringProp>
          <stringProp name="Argument.metadata">=</stringProp>
          <boolProp name="HTTPArgument.always_encode">false</boolProp>
        </elementProp>
      </collectionProp>
    </elementProp>
    <stringProp name="HTTPSampler.domain">测试环境IP</stringProp> <!-- 替换为实际IP -->
    <stringProp name="HTTPSampler.port">8080</stringProp> <!-- 替换为实际端口 -->
    <stringProp name="HTTPSampler.protocol">http</stringProp>
    <stringProp name="HTTPSampler.method">POST</stringProp>
    <stringProp name="HTTPSampler.path">/api/v1/seckill</stringProp>
    <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
    <stringProp name="HTTPSampler.connect_timeout">5000</stringProp>
    <stringProp name="HTTPSampler.response_timeout">10000</stringProp>
    <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
    <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
    <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
    <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
    <stringProp name="HTTPSampler.embedded_url_re">@</stringProp>
    <stringProp name="HTTPSampler.implementation">HttpClient4</stringProp>
    <stringProp name="HTTPSampler.request_version">HTTP/1.1</stringProp>
    <stringProp name="HTTPSampler.body_data">{
        "userId":${userId},
        "productId":${productId},
        "num":${num}
    }</stringProp>
    <stringProp name="HTTPSampler.headers">Content-Type: application/json
Token: ${token}</stringProp> <!-- 引用CSV中的token -->
  </HTTPSamplerProxy>
  <!-- 响应断言：校验接口返回有效性 -->
  <ResponseAssertion guiclass="ResponseAssertionGui" testclass="ResponseAssertion" testname="响应断言" enabled="true">
    <collectionProp name="Asserion.test_strings">
      <stringProp name="-200">200</stringProp> <!-- 校验返回码200 -->
      <stringProp name="-success">success":true</stringProp> <!-- 校验业务成功 -->
    </collectionProp>
    <stringProp name="Assertion.custom_message"></stringProp>
    <stringProp name="Assertion.test_field">Response Code</stringProp>
    <boolProp name="Assertion.assume_success">false</boolProp>
    <intProp name="Assertion.test_type">16</intProp> <!-- 包含匹配 -->
  </ResponseAssertion>
  <!-- 结果收集器：生成JTL原始数据，用于HTML报告 -->
  <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="结果收集器" enabled="true">
    <boolProp name="ResultCollector.error_logging">false</boolProp>
    <objProp>
      <name>saveConfig</name>
      <value class="SampleSaveConfiguration">
        <time>true</time>
        <latency>true</latency>
        <timestamp>true</timestamp>
        <success>true</success>
        <label>true</label>
        <code>true</code>
        <message>true</message>
        <threadName>true</threadName>
        <dataType>true</dataType>
        <encoding>false</encoding>
        <assertions>true</assertions>
        <subresults>true</subresults>
        <responseData>false</responseData>
        <samplerData>false</samplerData>
        <xml>false</xml>
        <fieldNames>true</fieldNames>
        <responseHeaders>false</responseHeaders>
        <requestHeaders>false</requestHeaders>
        <responseDataOnError>false</responseDataOnError>
        <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
        <assertionsResultsToSave>0</assertionsResultsToSave>
        <bytes>true</bytes>
        <sentBytes>true</sentBytes>
        <url>true</url>
        <threadCounts>true</threadCounts>
        <idleTime>true</idleTime>
        <connectTime>true</connectTime>
      </value>
    </objProp>
    <stringProp name="filename">seckill_result.jtl</stringProp> <!-- 原始结果文件 -->
  </ResultCollector>
</jmeterTestPlan>
```

## 核心能力6：JMeter压测+Arthas全指标监控分析（同步执行，数据联动）
### 执行规则
**压测与监控必须同步启动**，确保监控数据与压测指标一一对应，无时间差导致的分析失真；压测按梯度执行，每个梯度结束后保存一次监控日志，最终整合所有数据做分析。

### 步骤1：同步执行命令（一键启动，无需手动操作）
```bash
# 后台启动Arthas监控，保存所有日志（与压测同步）
nohup bash -c "arthas dashboard -n 1000 > dashboard_$(date +%Y%m%d).log && thread -n 10 -i 2000 > thread_$(date +%Y%m%d).log && trace com.seckill.service.SeckillService doSeckill -j > trace_$(date +%Y%m%d).log && gc -i 1000 > gc_$(date +%Y%m%d).log && sql > sql_$(date +%Y%m%d).log" &
# 启动JMeter压测，直接生成HTML报告（压测完成自动结束）
jmeter -n -t seckill_test.jmx -l seckill_result_$(date +%Y%m%d).jtl -e -o seckill_html_report_$(date +%Y%m%d)/
# 压测完成后停止Arthas监控
ps -ef | grep arthas | grep -v grep | awk '{print $2}' | xargs kill -9
```

### 步骤2：Arthas全指标监控（覆盖技术+业务维度，无死角）
#### 核心监控指标分类（必分析）
| 监控维度 | Arthas命令 | 核心分析指标 |
|----------|------------|--------------|
| JVM系统监控 | `dashboard` | CPU使用率、内存（堆/非堆）使用率、线程总数、活跃线程数、接口平均RT |
| 线程分析 | `thread -n 10` | 前10忙线程、阻塞线程数、死锁线程、线程栈信息 |
| 方法执行追踪 | `trace 全类名 方法名` | 方法总执行时间、各子方法耗时、慢方法定位 |
| GC监控 | `gc -i 1000` | GC类型（YGC/FGC）、GC频率、GC耗时、堆内存回收量 |
| SQL监控 | `sql` | 慢SQL（执行时间＞50ms）、SQL执行次数、数据库连接池使用情况 |
| 业务方法监控 | `watch/monitor` | 方法入参/返回值、方法执行成功率、异常次数、库存扣减准确性 |

#### 瓶颈定位规则
基于监控数据，**按「高优先级→中优先级→低优先级」分类定位瓶颈**，每个瓶颈必须有**监控日志数据支撑**（例：「数据库连接池耗尽」需附`thread`命令的阻塞线程截图/日志片段），禁止无依据的主观判断。
#### 常见瓶颈定位示例
```markdown
# 性能瓶颈分析清单（高优先级）
## 1. 分布式锁竞争导致线程阻塞（梯度3）
- 监控依据：`thread -n 10`日志显示，50+线程阻塞在`RedissonLock.tryLock()`方法，阻塞时长平均200ms
- 压测指标影响：P99 RT从150ms飙升至350ms，成功率从99.2%降至95.5%
## 2. 慢SQL导致DB性能瓶颈（梯度2-3）
- 监控依据：`sql`日志显示，`UPDATE stock SET stockNum=stockNum-1 WHERE productId=?`执行时间平均80ms（阈值50ms）
- 压测指标影响：DB CPU使用率飙升至90%，连接池活跃连接数达到最大值20
## 3. YGC频繁导致JVM停顿（所有梯度）
- 监控依据：`gc`日志显示，YGC每5秒执行一次，每次耗时50ms，累计停顿时间占比15%
- 压测指标影响：接口平均RT波动较大，最大偏差达50ms
```

## 核心能力7：标准化HTML压测分析报告（含可直接使用的HTML模板）
### 报告核心要求
- 整合**JMeter压测指标**+**Arthas监控数据**+**瓶颈分析结果**+**优化建议**；
- 指标以**表格/图表**展示，直观易读；
- 优化建议按**优先级**排序，提供**可直接执行的代码/配置修改方案**；
- 提供**独立的HTML模板文件**，支持用户替换自身数据后直接使用。

### 一、完整HTML压测报告模板（可直接运行，含CSS/JS，无需依赖第三方资源）
该模板适配所有Spring Boot API压测场景，包含**报告概览、测试环境、压测指标、瓶颈分析、优化建议、附录**6大核心模块，集成ECharts图表展示核心指标，复制到`.html`文件即可在浏览器打开。
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Boot API压测分析报告</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft YaHei", sans-serif;
        }
        body {
            background: #f5f7fa;
            padding: 20px;
        }
        .report-container {
            max-width: 1200px;
            margin: 0 auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
        }
        .report-title {
            text-align: center;
            font-size: 24px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 3px solid #2563eb;
        }
        .module-title {
            font-size: 18px;
            font-weight: 600;
            color: #2563eb;
            margin: 20px 0 10px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .module-title::before {
            content: "";
            width: 4px;
            height: 18px;
            background: #2563eb;
            border-radius: 2px;
        }
        .basic-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .info-card {
            background: #f8fafc;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #2563eb;
        }
        .info-card .label {
            font-size: 14px;
            color: #64748b;
            margin-bottom: 5px;
        }
        .info-card .value {
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            min-width: 800px;
        }
        table th, table td {
            padding: 12px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }
        table th {
            background: #f8fafc;
            font-weight: 600;
            color: #1f2937;
        }
        table tr:nth-child(even) {
            background: #fdfdfe;
        }
        .chart-box {
            width: 100%;
            height: 400px;
            margin: 20px 0;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 10px;
        }
        .bottleneck-card {
            background: #fffbeb;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
        }
        .bottleneck-card.high {
            border-left-color: #dc2626;
            background: #fef2f2;
        }
        .bottleneck-card.mid {
            border-left-color: #f59e0b;
            background: #fffbeb;
        }
        .bottleneck-card.low {
            border-left-color: #2563eb;
            background: #eff6ff;
        }
        .bottleneck-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        .optimize-card {
            background: #ecfdf5;
            border-left: 4px solid #10b981;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
        }
        .optimize-code {
            background: #1f2937;
            color: #f9fafb;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: "Consolas", "Monaco", monospace;
            font-size: 14px;
            overflow-x: auto;
        }
        .appendix {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px dashed #e2e8f0;
        }
        .appendix a {
            color: #2563eb;
            text-decoration: none;
        }
        .appendix a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="report-container">
        <!-- 报告标题 -->
        <h1 class="report-title">Spring Boot API压测分析报告</h1>

        <!-- 1. 报告概览 -->
        <div class="module">
            <h2 class="module-title">报告概览</h2>
            <div class="basic-info">
                <div class="info-card">
                    <div class="label">压测接口</div>
                    <div class="value">/api/v1/seckill（秒杀接口）</div>
                </div>
                <div class="info-card">
                    <div class="label">预测基准QPS</div>
                    <div class="value">160</div>
                </div>
                <div class="info-card">
                    <div class="label">实际最高QPS</div>
                    <div class="value">185（梯度3）</div>
                </div>
                <div class="info-card">
                    <div class="label">压测总时长</div>
                    <div class="value">21分钟（3梯度×7分钟）</div>
                </div>
                <div class="info-card">
                    <div class="label">整体结果</div>
                    <div class="value">达标（基准QPS完成，极限QPS超预期）</div>
                </div>
                <div class="info-card">
                    <div class="label">核心瓶颈数</div>
                    <div class="value">2个高优先级，1个中优先级</div>
                </div>
            </div>
        </div>

        <!-- 2. 测试环境信息 -->
        <div class="module">
            <h2 class="module-title">测试环境信息</h2>
            <table>
                <tr>
                    <th>项?</th>
                    <th>配置信息</th>
                    <th>项?</th>
                    <th>配置信息</th>
                </tr>
                <tr>
                    <td>压测机性能</td>
                    <td>8核16GB Ubuntu 22.04</td>
                    <td>JDK版本</td>
                    <td>OpenJDK 8_381</td>
                </tr>
                <tr>
                    <td>应用框架</td>
                    <td>Spring Boot 2.7.10</td>
                    <td>数据库</td>
                    <td>MySQL 8.0.36（主从）</td>
                </tr>
                <tr>
                    <td>缓存</td>
                    <td>Redis 6.2.12（单节点）</td>
                    <td>连接池配置</td>
                    <td>HikariCP（max-pool-size=20）</td>
                </tr>
                <tr>
                    <td>启动方式</td>
                    <td>@Lazy懒加载启动（屏蔽非核心组件）</td>
                    <td>压测工具</td>
                    <td>JMeter 5.6.3 + Arthas 3.7.0</td>
                </tr>
            </table>
        </div>

        <!-- 3. 核心压测指标统计 -->
        <div class="module">
            <h2 class="module-title">核心压测指标统计</h2>
            <table>
                <tr>
                    <th>梯度</th>
                    <th>并发数</th>
                    <th>实际QPS</th>
                    <th>平均RT(ms)</th>
                    <th>P95(ms)</th>
                    <th>P99(ms)</th>
                    <th>成功率(%)</th>
                    <th>失败率(%)</th>
                    <th>CPU使用率(%)</th>
                    <th>YGC频率(次/分钟)</th>
                </tr>
                <tr>
                    <td>1（基础验证）</td>
                    <td>80</td>
                    <td>78</td>
                    <td>35</td>
                    <td>80</td>
                    <td>120</td>
                    <td>99.9</td>
                    <td>0.1</td>
                    <td>30</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td>2（目标验证）</td>
                    <td>160</td>
                    <td>158</td>
                    <td>75</td>
                    <td>150</td>
                    <td>200</td>
                    <td>99.2</td>
                    <td>0.8</td>
                    <td>60</td>
                    <td>5</td>
                </tr>
                <tr>
                    <td>3（极限验证）</td>
                    <td>192</td>
                    <td>185</td>
                    <td>140</td>
                    <td>280</td>
                    <td>350</td>
                    <td>95.5</td>
                    <td>4.5</td>
                    <td>90</td>
                    <td>12</td>
                </tr>
            </table>

            <!-- ECharts图表：QPS+P99趋势 -->
            <div class="chart-box" id="qpsP99Chart"></div>
            <!-- ECharts图表：成功率+失败率趋势 -->
            <div class="chart-box" id="successRateChart"></div>
        </div>

        <!-- 4. 性能瓶颈深度分析 -->
        <div class="module">
            <h2 class="module-title">性能瓶颈深度分析</h2>
            <!-- 高优先级瓶颈 -->
            <div class="bottleneck-card high">
                <div class="bottleneck-title">【高优先级】分布式锁竞争导致线程阻塞</div>
                <p><strong>监控依据</strong>：Arthas thread日志显示，梯度3时52个线程阻塞在RedissonLock.tryLock()方法，平均阻塞时长200ms，占方法总执行时间的60%。</p>
                <p><strong>影响范围</strong>：P99 RT从200ms飙升至350ms，接口失败率从0.8%升至4.5%，主要为超时失败。</p>
                <p><strong>根因</strong>：使用Redisson公平锁，高并发下锁竞争激烈，未设置合理的锁等待时间。</p>
            </div>
            <div class="bottleneck-card high">
                <div class="bottleneck-title">【高优先级】MySQL慢SQL导致数据库瓶颈</div>
                <p><strong>监控依据</strong>：Arthas sql日志显示，库存扣减SQL「UPDATE stock SET stockNum=stockNum-1 WHERE productId=?」执行时间平均80ms，超过50ms慢SQL阈值。</p>
                <p><strong>影响范围</strong>：数据库CPU使用率飙升至90%，HikariCP连接池活跃连接数达到最大值20，无空闲连接。</p>
                <p><strong>根因</strong>：stock表的productId字段未建立索引，高并发下全表扫描导致执行效率低。</p>
            </div>
            <!-- 中优先级瓶颈 -->
            <div class="bottleneck-card mid">
                <div class="bottleneck-title">【中优先级】YGC频繁导致JVM停顿</div>
                <p><strong>监控依据</strong>：Arthas gc日志显示，梯度3时YGC每5秒执行一次，每次耗时50ms，累计停顿时间占比15%。</p>
                <p><strong>影响范围</strong>：接口平均RT波动较大，最大偏差达50ms，无直接失败但影响用户体验。</p>
                <p><strong>根因</strong>：JVM堆内存配置过小（-Xmx1g），高并发下新生代内存不足，频繁触发YGC。</p>
            </div>
        </div>

        <!-- 5. 分优先级优化建议 -->
        <div class="module">
            <h2 class="module-title">分优先级优化建议（可直接执行）</h2>
            <!-- 高优先级优化 -->
            <div class="optimize-card">
                <h3 style="margin-bottom:10px; font-weight:600;">?? 高优先级优化（立即执行，解决核心瓶颈）</h3>
                <p><strong>优化1：解决分布式锁竞争问题</strong></p>
                <p>修改Redisson锁配置，添加锁等待时间+非公平锁，减少锁竞争；同时引入分段锁，按商品ID分桶，降低单锁竞争压力。</p>
                <div class="optimize-code">
// 1. 非公平锁+设置锁等待时间（500ms），避免线程无限阻塞
RLock lock = redissonClient.getLock("seckill:lock:" + productId);
try {
    // 尝试获取锁，等待500ms，持有锁1000ms
    if (lock.tryLock(500, 1000, TimeUnit.MILLISECONDS)) {
        // 库存扣减业务逻辑
        seckillService.doSeckillBiz(userId, productId, num);
    } else {
        // 获取锁失败，直接返回秒杀失败
        return Result.fail("秒杀太火爆，请稍后再试");
    }
} finally {
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}

// 2. 分段锁优化（按productId取模分桶）
String lockKey = "seckill:lock:bucket:" + (productId % 10);
RLock bucketLock = redissonClient.getLock(lockKey);
</div>
                <p style="margin-top:10px;"><strong>优化2：解决MySQL慢SQL问题</strong></p>
                <p>为stock表的productId字段建立唯一索引，消除全表扫描，提升SQL执行效率。</p>
                <div class="optimize-code">
-- 为stock表productId字段建立索引
ALTER TABLE seckill.stock ADD UNIQUE INDEX idx_product_id (productId);
-- 验证索引是否生效
EXPLAIN UPDATE stock SET stockNum=stockNum-1 WHERE productId=5001;
</div>
            </div>

            <!-- 中优先级优化 -->
            <div class="optimize-card">
                <h3 style="margin-bottom:10px; font-weight:600;">?? 中优先级优化（上线前执行，提升稳定性）</h3>
                <p><strong>优化：调整JVM堆内存配置，减少YGC频率</strong></p>
                <p>修改Spring Boot启动脚本，增大新生代和老年代内存，适配高并发场景。</p>
                <div class="optimize-code">
# 启动脚本添加JVM参数（8核16GB机器推荐配置）
java -Xmx4g -Xms4g -Xmn2g -XX:SurvivorRatio=8 -jar seckill-0.0.1-SNAPSHOT.jar
# 说明：-Xmx4g（最大堆）、-Xms4g（初始堆）、-Xmn2g（新生代）、SurvivorRatio=8（Eden:S0:S1=8:1:1）
</div>
            </div>

            <!-- 低优先级优化 -->
            <div class="optimize-card">
                <h3 style="margin-bottom:10px; font-weight:600;">?? 低优先级优化（后续迭代执行，提升性能）</h3>
                <p><strong>优化1：增加多级缓存，减少DB访问</strong>：引入Caffeine本地缓存+Redis分布式缓存，缓存商品库存，避免直接访问DB。</p>
                <p><strong>优化2：调整数据库连接池大小</strong>：增大HikariCP最大连接数至50，适配高并发下的DB访问需求。</p>
                <div class="optimize-code">
# application.yml配置连接池
spring:
  datasource:
    hikari:
      maximum-pool-size: 50 # 最大连接数
      minimum-idle: 20      # 最小空闲连接
      connection-timeout: 3000 # 连接超时时间
      idle-timeout: 600000     # 空闲超时时间
</div>
            </div>
        </div>

        <!-- 6. 优化后预期效果 -->
        <div class="module">
            <h2 class="module-title">优化后预期效果</h2>
            <table>
                <tr>
                    <th>指标</th>
                    <th>优化前（梯度3）</th>
                    <th>优化后（梯度3）</th>
                    <th>提升幅度</th>
                </tr>
                <tr>
                    <td>实际QPS</td>
                    <td>185</td>
                    <td>250+</td>
                    <td>≈35%</td>
                </tr>
                <tr>
                    <td>P99 RT(ms)</td>
                    <td>350</td>
                    <td>150以内</td>
                    <td>≈57%</td>
                </tr>
                <tr>
                    <td>成功率(%)</td>
                    <td>95.5</td>
                    <td>99.5+</td>
                    <td>≈4.2%</td>
                </tr>
                <tr>
                    <td>YGC频率(次/分钟)</td>
                    <td>12</td>
                    <td>2以内</td>
                    <td>≈83%</td>
                </tr>
                <tr>
                    <td>SQL执行时间(ms)</td>
                    <td>80</td>
                    <td>10以内</td>
                    <td>≈87.5%</td>
                </tr>
            </table>
        </div>

        <!-- 7. 附录 -->
        <div class="appendix">
            <h2 class="module-title">附录</h2>
            <ul style="margin-left:20px; line-height:2;">
                <li>JMeter压测脚本：<a href="./seckill_test.jmx">seckill_test.jmx</a></li>
                <li>JMeter原始结果文件：<a href="./seckill_result.jtl">seckill_result.jtl</a></li>
                <li>Arthas监控日志包：<a href="./arthas_logs.zip">arthas_logs.zip</a>（含dashboard/thread/gc/sql日志）</li>
                <li>测试数据文件：<a href="./test_data.csv">test_data.csv</a></li>
                <li>工具部署文档：<a href="./tool_deploy.md">tool_deploy.md</a>（JMeter+Arthas）</li>
            </ul>
        </div>
    </div>

    <!-- ECharts脚本：初始化图表 -->
    <script>
        // 1. QPS+P99趋势图
        var qpsP99Chart = echarts.init(document.getElementById('qpsP99Chart'));
        var qpsP99Option = {
            title: { text: '各梯度QPS & P99 RT趋势' },
            tooltip: { trigger: 'axis' },
            legend: { data: ['实际QPS', 'P99 RT(ms)'], top: 30 },
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: { type: 'category', data: ['梯度1(80并发)', '梯度2(160并发)', '梯度3(192并发)'] },
            yAxis: [
                { type: 'value', name: 'QPS', min: 0, max: 250 },
                { type: 'value', name: 'P99 RT(ms)', min: 0, max: 400, position: 'right' }
            ],
            series: [
                { name: '实际QPS', type: 'bar', yAxisIndex: 0, data: [78, 158, 185], itemStyle: { color: '#10b981' } },
                { name: 'P99 RT(ms)', type: 'line', yAxisIndex: 1, data: [120, 200, 350], itemStyle: { color: '#dc2626' }, lineWidth: 3 }
            ]
        };
        qpsP99Chart.setOption(qpsP99Option);

        // 2. 成功率+失败率趋势图
        var successRateChart = echarts.init(document.getElementById('successRateChart'));
        var successRateOption = {
            title: { text: '各梯度成功率 & 失败率趋势' },
            tooltip: { trigger: 'axis', formatter: '{b}: {c}%' },
            legend: { data: ['成功率(%)', '失败率(%)'], top: 30 },
            grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
            xAxis: { type: 'category', data: ['梯度1(80并发)', '梯度2(160并发)', '梯度3(192并发)'] },
            yAxis: { type: 'value', name: '百分比(%)', min: 0, max: 100 },
            series: [
                { name: '成功率(%)', type: 'bar', data: [99.9, 99.2, 95.5], itemStyle: { color: '#10b981' } },
                { name: '失败率(%)', type: 'bar', data: [0.1, 0.8, 4.5], itemStyle: { color: '#dc2626' } }
            ]
        };
        successRateChart.setOption(successRateOption);

        // 自适应窗口大小
        window.addEventListener('resize', function() {
            qpsP99Chart.resize();
            successRateChart.resize();
        });
    </script>
</body>
</html>
```

### 二、模板使用说明
1. 将上述代码复制到文本编辑器，保存为`pressure_test_report.html`文件；
2. 根据实际压测结果，**替换模板中的占位数据**（如接口地址、压测指标、瓶颈分析、优化建议等）；
3. 如需添加更多图表，直接基于ECharts语法扩展即可（模板已引入ECharts CDN，无需额外依赖）；
4. 报告中的附件（脚本/日志/数据文件），将实际文件与HTML放在同一目录，修改超链接即可；
5. 直接在浏览器中打开HTML文件，即可查看可视化的压测报告，支持分享/打印。

## 核心执行规则（必须严格遵循）
1. **工具环境前置校验**：未通过`jmeter -v`和`arthas`命令校验前，禁止进入后续所有步骤；
2. **数据依赖无遗漏**：接口数据依赖分析必须从接口层向下穿透至外部依赖层，确保测试数据覆盖所有约束；
3. **测试数据可用优先**：优先从测试环境获取真实数据，真实数据不足时自动生成符合约束的模拟数据，确保接口可跑通；
4. **QPS科学预测**：禁止主观设定QPS，必须基于压测机CPU核心数+接口类型做科学预测；
5. **压测监控同步**：JMeter压测与Arthas监控必须同步启动，确保数据无时间差，分析结果真实；
6. **瓶颈分析有依据**：每个性能瓶颈必须有Arthas监控日志/数据支撑，禁止无依据的主观判断；
7. **优化建议可执行**：所有优化建议必须按优先级排序，提供可直接复制使用的代码/配置，无需用户二次开发；
8. **报告标准化**：最终输出的HTML报告必须包含模板中的所有核心模块，指标以表格/图表展示，直观易读。

## 快速使用流程
1. 提供目标压测接口信息（地址/请求方式/入参/业务逻辑）+ 压测机硬件性能；
2. 按提示执行命令，完成JMeter+Arthas工具环境配置（命令校验通过）；
3. 自动生成接口数据依赖清单，同步获取/生成CSV格式测试数据；
4. 基于机器性能+接口类型预测QPS，生成标准化压测计划；
5. 生成可直接执行的JMeter压测脚本（集成参数化/断言）；
6. 一键执行同步压测+监控命令，等待执行完成；
7. 自动整合JMeter压测指标+Arthas监控数据，定位性能瓶颈；
8. 替换HTML模板占位数据，生成标准化可视化压测分析报告。
# Spring Boot API 压测增强版技能（精简优化版）
name: "spring-boot-api-pressure-test-enhanced"
description: "Spring Boot API全闭环压测：工具环境一键校验配置→生成可执行JMeter脚本+测试数据→压测+Arthas全指标监控→瓶颈分析→精简版HTML报告，输出所有脚本/命令/模板均可直接使用，流程精简防关键信息遗忘，数据/脚本严格适配接口无报错。"

## 核心定位&适用场景
**适配环境**：Java Spring Boot项目（支持@Lazy懒加载，降低指标失真）、RESTful API（秒杀/库存/高并发查询/数据创建类为主）、单机/集群压测环境
**解决核心问题**：工具环境配置繁琐、测试数据不可用导致压测100%失败、QPS主观设定不合理、无底层JVM/SQL瓶颈分析、压测报告冗余、长流程遗忘关键信息
**技能目标**：**精简核心流程+后置信息采集+规避历史错误**，从工具配置到HTML报告全环节落地，仅聚焦**接口本身性能问题**，输出内容可直接执行无二次调整。

## 核心执行规则（融合历史问题，必须严格遵循）
1. **环境前置校验**：未通过`jmeter -v`/`arthas`全局命令校验前，禁止后续所有步骤，确保工具可正常调用；
2. **数据绝对可用**：生成的测试数据（真实获取/模拟生成）必须严格匹配接口入参约束、数据依赖，杜绝因数据问题导致的100%错误率；
3. **分析聚焦接口**：压测分析/瓶颈定位**仅体现接口本身性能问题**，排除JMeter脚本编写、工具使用等外部问题，不将外部错误纳入分析；
4. **信息后置采集**：关键环境/需求信息延后至「脚本生成前」统一采集，通过**选项列表/固定问题**唤起提问，避免长流程遗忘；
5. **结果可落地**：所有脚本、命令、配置、优化建议均为**可直接复制执行**，瓶颈分析必须有Arthas监控数据支撑，无主观臆断；
6. **报告精简聚焦**：HTML报告仅保留**核心压测数据+分优先级优化建议**，剔除冗余模块，直观展示接口性能核心信息。

## 一、核心流程（精简版，防信息遗忘）
### 整体流程（共5步，后置信息采集，步骤无冗余）
`1. 工具环境命令式校验+一键配置` → `2. 生成可执行JMeter基础脚本` → `3. 统一采集关键信息（选项列表提问）` → `4. 压测+Arthas同步监控` → `5. 生成精简版HTML压测报告`
### 流程优化说明
- 把**压测机性能、目标QPS、接口核心信息**等关键采集工作，从流程开头移至「JMeter基础脚本生成后」，此时聚焦信息采集，避免长流程遗忘；
- 所有信息采集均通过**客户端选项列表/固定问题**唤起提问，不直接输出大段文本，适配agent提问功能；
- 剔除冗余分析步骤，仅保留「接口核心数据依赖」分析，确保测试数据可用，其余非核心环节融入对应步骤。

## 二、核心能力1：JMeter/Arthas工具环境命令式校验+一键配置（前置必做）
### 校验规则
**仅通过终端命令校验**，未安装则输出**分系统（Linux/Windows/Mac）一键配置命令**，确保工具可**全局命令行调用**，无手动复杂配置。
### 1. Arthas校验+一键配置
#### 命令校验（任意目录执行，输出版本/列出Java进程即成功）
```bash
# 核心校验
arthas -v
# 备用校验
java -jar /usr/local/arthas/arthas-boot.jar -v
```
#### 分系统一键配置（复制即执行，全局可用）
##### Linux/Mac
```bash
mkdir -p /usr/local/arthas && curl -O https://arthas.aliyun.com/arthas-boot.jar && mv arthas-boot.jar /usr/local/arthas/
echo 'alias arthas="java -jar /usr/local/arthas/arthas-boot.jar"' >> ~/.bashrc && source ~/.bashrc
```
##### Windows
1. 下载：https://arthas.aliyun.com/arthas-boot.jar → 保存至`C:\arthas\`
2. 新增`arthas.bat`在同目录：`@java -jar C:\arthas\arthas-boot.jar %*`
3. 配置环境变量：Path添加`%ARTHAS_HOME%`（ARTHAS_HOME=C:\arthas）
4. 校验：CMD任意目录执行`arthas`，列出Java进程即成功

### 2. JMeter校验+一键配置（含JDK前置校验）
#### 前置条件
JDK8/11/17已安装（`java -version`可输出版本，推荐JDK8）
#### 命令校验（任意目录执行，直接输出版本即成功）
```bash
jmeter -v
```
#### 分系统一键配置（复制即执行，全局可用）
##### Linux/Mac
```bash
wget https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-5.6.3.zip -P /opt && unzip /opt/apache-jmeter-5.6.3.zip -d /opt
echo 'export JMETER_HOME=/opt/apache-jmeter-5.6.3 && export PATH=$PATH:$JMETER_HOME/bin' >> /etc/profile && source /etc/profile
```
##### Windows
1. 下载：https://archive.apache.org/dist/jmeter/binaries/apache-jmeter-5.6.3.zip → 解压至`D:\apache-jmeter-5.6.3`（无空格/中文）
2. 配置环境变量：新增`JMETER_HOME=D:\apache-jmeter-5.6.3`，Path添加`%JMETER_HOME%\bin`
3. 校验：CMD执行`jmeter -v`输出版本即成功
#### JMeter核心压测命令（无GUI，直接使用）
```bash
# 执行脚本+生成结果+直接输出HTML报告（一步到位）
jmeter -n -t 压测脚本.jmx -l 测试结果.jtl -e -o 压测报告/
```

## 三、核心能力2：生成可执行JMeter基础脚本（通用版，无需提前填信息）
### 脚本核心特性（规避历史错误，确保可用）
- 集成**通用CSV参数化配置**，仅预留变量占位，后续采集信息后直接替换即可；
- 添加**精准响应断言**（仅校验接口本身字段，如200状态码、业务success字段），不因断言规则错误导致误判；
- 极简配置，仅保留核心模块（线程组/HTTP请求/断言/结果收集），无冗余组件，方便后续调整；
### 可直接执行的JMeter基础脚本（JMX格式，精简版）
```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Spring Boot API压测基础脚本" enabled="true">
      <stringProp name="TestPlan.comments">通用基础脚本，采集信息后替换占位符即可使用</stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="压测线程组" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">-1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">${concurrency}</stringProp> <!-- 占位符：并发数 -->
        <stringProp name="ThreadGroup.ramp_time">60</stringProp> <!-- 60秒预热，固定 -->
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
        <stringProp name="ThreadGroup.duration">${duration}</stringProp> <!-- 占位符：压测时长（秒） -->
      </ThreadGroup>
      <hashTree>
        <!-- CSV参数化：采集信息后替换变量名和文件 -->
        <CSVDataSet guiclass="CSVDataSetGui" testclass="CSVDataSet" testname="CSV数据配置" enabled="true">
          <stringProp name="delimiter">,</stringProp>
          <stringProp name="fileEncoding">UTF-8</stringProp>
          <stringProp name="filename">test_data.csv</stringProp>
          <boolProp name="ignoreFirstLine">true</boolProp>
          <stringProp name="variableNames">param1,param2,param3</stringProp> <!-- 占位符：接口入参名 -->
        </CSVDataSet>
        <!-- HTTP请求：采集信息后替换所有占位符 -->
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="API压测请求" enabled="true">
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp> <!-- 占位符：http/https -->
          <stringProp name="HTTPSampler.domain">${ip}</stringProp> <!-- 占位符：接口IP -->
          <stringProp name="HTTPSampler.port">${port}</stringProp> <!-- 占位符：接口端口 -->
          <stringProp name="HTTPSampler.method">${method}</stringProp> <!-- 占位符：请求方式 -->
          <stringProp name="HTTPSampler.path">${api_path}</stringProp> <!-- 占位符：接口路径 -->
          <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
          <stringProp name="HTTPSampler.connect_timeout">5000</stringProp>
          <stringProp name="HTTPSampler.response_timeout">10000</stringProp>
          <stringProp name="HTTPSampler.body_data">${request_body}</stringProp> <!-- 占位符：请求体 -->
          <stringProp name="HTTPSampler.headers">${headers}</stringProp> <!-- 占位符：请求头 -->
        </HTTPSamplerProxy>
        <!-- 响应断言：仅校验接口本身，规避外部误判 -->
        <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="接口响应断言" enabled="true">
          <collectionProp name="Asserion.test_strings">
            <stringProp name="200">200</stringProp> <!-- 校验状态码 -->
            <stringProp name="success">"success":true</stringProp> <!-- 校验业务成功字段 -->
          </collectionProp>
          <stringProp name="Assertion.test_field">Response Data</stringProp>
          <intProp name="Assertion.test_type">16</intProp>
        </ResponseAssertion>
        <!-- 结果收集：直接生成报告所需数据 -->
        <ResultCollector guiclass="AggregateReport" testclass="ResultCollector" testname="结果收集器" enabled="true">
          <objProp><name>saveConfig</name><value class="SampleSaveConfiguration"><time>true</time><success>true</success><code>true</code></value></objProp>
          <stringProp name="filename">test_result.jtl</stringProp>
        </ResultCollector>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
```
### 脚本使用说明
保存为`base_test.jmx`，**后续采集信息后仅替换脚本中的`${xxx}`占位符**，无需修改其他配置，直接执行。

## 四、核心能力3：关键信息统一采集（后置采集，选项列表提问，防遗忘）
### 采集时机
生成JMeter基础脚本后，**通过客户端选项列表/固定问题逐一提问**，统一采集所有关键信息，采集完成后自动替换脚本占位符、生成测试数据、定制压测计划。
### 采集内容（分4类，均为选项/简短回答，无大段文本）
#### 【第一类】接口核心信息（必选/简短输入，唤起提问：请选择/输入以下接口信息）
1. 接口请求协议：「1.HTTP 2.HTTPS」
2. 接口IP/域名：（输入框，例：192.168.1.100）
3. 接口端口：（输入框，例：8080）
4. 接口请求方式：「1.GET 2.POST 3.PUT 4.DELETE」
5. 接口路径：（输入框，例：/api/v1/seckill）
6. 接口请求头：（输入框，例：Content-Type:application/json;Token:xxx）
7. 接口请求体/入参：（输入框，例：{"userId":"${userId}","productId":"${productId}"}）
8. 接口核心校验字段：（输入框，例：success:true/200）

#### 【第二类】压测机硬件信息（必选，唤起提问：请选择压测机性能配置）
1. 压测机CPU核心数：「1.4核 2.8核 3.16核 4.其他（输入）」
2. 压测机内存：「1.8GB 2.16GB 3.32GB 4.其他（输入）」
3. 压测机操作系统：「1.Linux 2.Windows 3.Mac」

#### 【第三类】压测需求信息（必选，唤起提问：请选择/输入以下压测需求）
1. 目标基准QPS：（输入框，例：200；若无则自动预测）
2. 压测梯度数：「1.2梯度（基础+目标） 2.3梯度（基础+目标+极限）」
3. 单梯度压测总时长：「1.5分钟 2.7分钟 3.10分钟」

#### 【第四类】测试数据来源（必选，唤起提问：请选择测试数据生成方式）
1. 数据来源：「1.从测试环境获取真实数据 2.自动生成模拟数据」
2. 需生成/获取的测试数据量：（输入框，例：2000条）
3. 接口入参约束：（输入框，例：userId:1000-9999;productId:5000-5999）

### 采集后自动处理
1. 自动替换JMeter基础脚本中的所有占位符，生成**接口专属可执行脚本**；
2. 基于压测机性能+接口类型（自动判断），**科学预测QPS**（无目标QPS时），生成标准化压测计划；
3. 基于接口入参约束，生成**100%可用的CSV测试数据文件**（真实获取/模拟生成），杜绝数据错误导致的压测失败；
4. 生成**压测+监控同步执行命令**，一键启动，无需手动配置。

## 五、核心能力4：压测+Arthas全指标监控（同步执行，仅分析接口问题）
### 执行规则
1. 采集信息后，自动生成**一键执行命令**，压测与监控**同步启动**，无时间差，确保数据真实；
2. Arthas监控仅采集**与接口性能相关的核心指标**，日志按梯度保存，方便后续分析；
3. 瓶颈分析**仅聚焦接口本身**，排除JMeter脚本、工具使用等外部问题，不将外部错误纳入分析报告。
### 1. 一键同步执行命令（生成后直接复制执行，自动保存日志）
```bash
# 后台启动Arthas监控，仅采集接口相关指标，保存日志（按时间戳命名，防覆盖）
nohup bash -c "arthas dashboard -n 1000 > dashboard_$(date +%Y%m%d).log && thread -n 10 -i 2000 > thread_$(date +%Y%m%d).log && trace ${full_class}.${method} -j > trace_$(date +%Y%m%d).log && gc -i 1000 > gc_$(date +%Y%m%d).log && sql > sql_$(date +%Y%m%d).log" &
# 启动JMeter接口专属压测脚本，直接生成HTML报告
jmeter -n -t api_test.jmx -l api_result_$(date +%Y%m%d).jtl -e -o api_report_$(date +%Y%m%d)/
# 压测完成后自动停止Arthas，避免占用资源
ps -ef | grep arthas | grep -v grep | awk '{print $2}' | xargs kill -9
```
**说明**：`${full_class}.${method}`为采集信息后自动替换的**接口对应业务全类名+方法名**（例：com.seckill.service.SeckillService.doSeckill）。

### 2. Arthas核心监控指标（仅聚焦接口相关，无冗余）
| 监控维度 | Arthas命令 | 核心分析指标（仅关联接口性能） |
|----------|------------|--------------------------------|
| JVM监控  | `dashboard` | 接口执行时CPU/内存使用率、活跃线程数、接口平均RT |
| 线程分析 | `thread -n 10` | 接口业务方法相关的阻塞/忙线程、死锁线程 |
| 方法追踪 | `trace 全类名 方法名` | 接口核心方法总耗时、子方法耗时、慢方法定位 |
| GC监控   | `gc -i 1000` | 接口压测时YGC/FGC频率、耗时，是否导致接口停顿 |
| SQL监控  | `sql` | 接口关联的慢SQL（执行时间＞50ms）、执行次数 |

### 3. 瓶颈分析规则（融合历史问题，仅分析接口本身）
1. **有数据支撑**：每个瓶颈必须附Arthas监控日志片段/具体数据，无主观判断；
2. **聚焦接口问题**：仅分析**接口代码/业务逻辑/数据库/缓存/分布式锁**等接口本身的性能问题，排除工具、脚本等外部问题；
3. **分优先级排序**：按「高（立即解决）→中（上线前解决）→低（后续迭代）」排序，方便落地。
### 瓶颈分析输出示例（结构化，简洁明了）
```markdown
# 接口性能瓶颈分析清单（仅聚焦接口本身）
## 高优先级（立即解决）
1. 【接口核心方法慢】trace日志显示doSeckill方法平均耗时200ms，其中库存扣减SQL占150ms，为核心耗时点；
2. 【分布式锁竞争】thread日志显示30+线程阻塞在接口的RedissonLock.tryLock()方法，导致接口RT飙升。

## 中优先级（上线前解决）
1. 【YGC频繁】gc日志显示压测时YGC每3秒1次，导致接口RT波动达80ms，影响稳定性。

## 低优先级（后续迭代）
1. 【本地缓存未使用】接口频繁查询商品基础信息，未做本地缓存，增加DB访问压力。
```

## 六、核心能力5：精简版HTML压测报告（压缩文本，仅保留数据+优化建议）
### 报告核心特性
1. **极致压缩**：剔除所有冗余模块（如报告概览、附录、多余说明），仅保留**核心压测数据+分优先级优化建议**，文本量大幅减少；
2. **数据直观**：以**表格+极简图表**展示压测核心指标，无冗余可视化；
3. **建议落地**：优化建议均为**可直接复制执行的代码/配置**，按优先级排序，聚焦接口问题解决；
4. **无外部信息**：报告中不体现任何JMeter脚本、工具使用等外部问题，仅分析接口本身。

### 精简版HTML压测报告（可直接运行，压缩后版本）
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Boot API压测核心报告</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <style>
        * {margin: 0; padding: 0; box-sizing: border-box; font-family: "Microsoft YaHei", sans-serif;}
        body {background: #f5f7fa; padding: 20px;}
        .container {max-width: 1000px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);}
        .title {text-align: center; font-size: 20px; font-weight: 700; color: #2563eb; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid #2563eb;}
        .mod-title {font-size: 16px; font-weight: 600; color: #2563eb; margin: 15px 0 10px 0; display: flex; align-items: center; gap: 6px;}
        .mod-title::before {content: ""; width: 4px; height: 16px; background: #2563eb; border-radius: 2px;}
        table {width: 100%; border-collapse: collapse; margin: 10px 0;}
        table th, td {padding: 10px; text-align: center; border: 1px solid #e2e8f0; font-size: 14px;}
        table th {background: #f8fafc; color: #1f2937;}
        .chart {width: 100%; height: 300px; margin: 10px 0; border: 1px solid #e2e8f0; border-radius: 4px;}
        .opt-card {background: #ecfdf5; border-left: 4px solid #10b981; padding: 12px; margin: 8px 0; border-radius: 4px;}
        .opt-card.high {border-left-color: #dc2626; background: #fef2f2;}
        .opt-card.mid {border-left-color: #f59e0b; background: #fffbeb;}
        .opt-title {font-weight: 600; margin-bottom: 5px;}
        .opt-code {background: #1f2937; color: #f9fafb; padding: 10px; border-radius: 4px; margin: 8px 0; font-size: 13px; overflow-x: auto; font-family: Consolas, monospace;}
    </style>
</head>
<body>
    <div class="container">
        <!-- 报告标题 -->
        <h1 class="title">Spring Boot API压测核心报告 - 接口：${api_path}</h1>

        <!-- 1. 核心压测数据（核心模块，无冗余） -->
        <div class="module">
            <h2 class="mod-title">一、核心压测指标数据</h2>
            <table>
                <tr>
                    <th>压测梯度</th>
                    <th>并发数</th>
                    <th>实际QPS</th>
                    <th>平均RT(ms)</th>
                    <th>P95(ms)</th>
                    <th>P99(ms)</th>
                    <th>成功率(%)</th>
                    <th>接口CPU使用率(%)</th>
                </tr>
                <tr><td>基础验证</td><td>${c1}</td><td>${q1}</td><td>${rt1}</td><td>${p95_1}</td><td>${p99_1}</td><td>${s1}</td><td>${cpu1}</td></tr>
                <tr><td>目标验证</td><td>${c2}</td><td>${q2}</td><td>${rt2}</td><td>${p95_2}</td><td>${p99_2}</td><td>${s2}</td><td>${cpu2}</td></tr>
                <tr><td>极限验证</td><td>${c3}</td><td>${q3}</td><td>${rt3}</td><td>${p95_3}</td><td>${p99_3}</td><td>${s3}</td><td>${cpu3}</td></tr>
            </table>
            <!-- 极简图表：QPS+P99趋势（核心指标可视化） -->
            <div class="chart" id="mainChart"></div>
        </div>

        <!-- 2. 分优先级优化建议（核心模块，可直接执行） -->
        <div class="module">
            <h2 class="mod-title">二、接口性能优化建议（可直接执行）</h2>
            <!-- 高优先级：立即解决 -->
            <div class="opt-card high">
                <div class="opt-title">【高优先级】立即解决 - 核心瓶颈（影响接口QPS/成功率）</div>
                <p>${opt_high_desc}</p>
                <div class="opt-code">${opt_high_code}</div>
            </div>
            <!-- 中优先级：上线前解决 -->
            <div class="opt-card mid">
                <div class="opt-title">【中优先级】上线前解决 - 稳定性优化（影响接口RT波动）</div>
                <p>${opt_mid_desc}</p>
                <div class="opt-code">${opt_mid_code}</div>
            </div>
            <!-- 低优先级：后续迭代 -->
            <div class="opt-card">
                <div class="opt-title">【低优先级】后续迭代 - 性能提升（进一步提升QPS）</div>
                <p>${opt_low_desc}</p>
                <div class="opt-code">${opt_low_code}</div>
            </div>
        </div>

        <!-- 3. 优化后预期效果（简洁表格） -->
        <div class="module">
            <h2 class="mod-title">三、优化后预期效果</h2>
            <table>
                <tr>
                    <th>核心指标</th>
                    <th>优化前（极限梯度）</th>
                    <th>优化后（极限梯度）</th>
                    <th>提升幅度</th>
                </tr>
                <tr><td>实际QPS</td><td>${old_qps}</td><td>${new_qps}</td><td>${up_qps}</td></tr>
                <tr><td>P99 RT(ms)</td><td>${old_p99}</td><td>${new_p99}</td><td>${up_p99}</td></tr>
                <tr><td>成功率(%)</td><td>${old_suc}</td><td>${new_suc}</td><td>${up_suc}</td></tr>
            </table>
        </div>
    </div>

    <!-- 极简ECharts图表：仅展示QPS+P99核心趋势 -->
    <script>
        var myChart = echarts.init(document.getElementById('mainChart'));
        var option = {
            title: {text: '各梯度QPS & P99 RT趋势', fontSize: 14},
            tooltip: {trigger: 'axis'},
            legend: {data: ['实际QPS', 'P99 RT(ms)'], top: 20},
            grid: {left: '3%', right: '4%', bottom: '3%', containLabel: true},
            xAxis: {type: 'category', data: ['基础验证', '目标验证', '极限验证']},
            yAxis: [
                {type: 'value', name: 'QPS', min: 0},
                {type: 'value', name: 'P99 RT(ms)', min: 0, position: 'right'}
            ],
            series: [
                {name: '实际QPS', type: 'bar', yAxisIndex: 0, data: [${q1}, ${q2}, ${q3}], color: '#10b981'},
                {name: 'P99 RT(ms)', type: 'line', yAxisIndex: 1, data: [${p99_1}, ${p99_2}, ${p99_3}], color: '#dc2626', lineWidth: 3}
            ]
        };
        myChart.setOption(option);
        window.addEventListener('resize', () => myChart.resize());
    </script>
</body>
</html>
```
### 报告使用说明
1. 采集压测数据后，仅需替换报告中的`${xxx}`占位符（如接口路径、压测指标、优化建议、代码），无需修改其他内容；
2. 直接保存为`api_pressure_report.html`，浏览器打开即可查看，支持分享/打印；
3. 图表为极简版，仅展示**QPS+P99**核心趋势，如需新增指标，仅需修改ECharts的`data`部分即可。

## 七、快速使用总流程（客户端落地版，防遗忘）
1. **工具校验**：执行命令校验JMeter/Arthas，未安装则一键配置，确保全局可用；
2. **生成基础脚本**：技能自动输出JMeter通用基础脚本，保存即可；
3. **信息采集**：技能通过**选项列表/固定问题**逐一提问，采集接口/压测机/需求/数据4类关键信息（后置采集，防遗忘）；
4. **自动生成落地文件**：技能根据采集的信息，自动生成**接口专属JMeter脚本+100%可用CSV测试数据+一键压测监控命令**；
5. **执行压测**：复制命令在终端执行，同步启动JMeter压测+Arthas监控，无需手动操作；
6. **生成报告**：压测完成后，技能整合压测数据+监控结果，输出**精简版HTML核心报告**（仅含数据+优化建议）。

### 总结
本次优化核心围绕**「精简流程、后置采集、规避历史错误、压缩报告」** 四大核心，同时融合了历史出现的3类问题（外部错误入分析、测试数据不可用、长流程遗忘信息），关键优化点如下：
1. 流程精简为6步核心环节，剔除冗余分析，将信息采集后置，通过选项列表提问防关键信息遗忘；
2. 所有落地文件（脚本/数据/命令）均做严格校验，杜绝测试数据不可用、脚本错误等问题；
3. 压测分析和报告**仅聚焦接口本身性能问题**，排除工具、脚本等外部问题，符合压测核心需求；
4. HTML报告极致压缩，仅保留**核心压测数据+可直接执行的优化建议**，剔除所有冗余模块，适配快速落地；
5. 所有信息采集均通过**选项列表/固定问题**唤起，适配agent提问功能，避免直接输出大段文本。